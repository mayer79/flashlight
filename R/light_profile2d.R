#' 2D Partial Dependence and other 2D Profiles
#'
#' Calculates different types of 2D-profiles across two variables. By default, partial dependence profiles are calculated (see Friedman). Other options are response, predicted values, residuals, and shap. The results are aggregated by (weighted) means.
#'
#' Different binning options are available, see arguments below.
#' For partial dependence and prediction profiles, "model", "predict_function", linkinv" and "data" are required. For response profiles it is "y", "linkinv" and "data" and for shap profiles it is just "shap". "data" can be passed on the fly.
#'
#' @importFrom withr with_options
#' @param x An object of class \code{flashlight} or \code{multiflashlight}.
#' @param v A vector of exactly two variable names to be profiled.
#' @param data An optional \code{data.frame}. Not used for \code{type = "shap"}.
#' @param by An optional vector of column names used to additionally group the results.
#' @param type Type of the profile: Either "partial dependence", "predicted", "response", "residual", or "shap".
#' @param breaks Named list of cut breaks specifying how to bin one or more numeric variables. Used to overwrite automatic binning via \code{n_bins} and \code{cut_type}. Ignored for non-numeric \code{v}.
#' @param n_bins Approximate number of unique values to evaluate for numeric \code{v}. Can be an unnamed vector of length 2 to distinguish between v.
#' @param cut_type Should numeric \code{v} be cut into "equal" or "quantile" bins? Can be an unnamed vector of length 2 to distinguish between v.
#' @param use_linkinv Should retransformation function be applied? Default is TRUE. Not used for type "shap".
#' @param counts Should observation counts be added?
#' @param counts_weighted If \code{counts} is TRUE: Should counts be weighted by the case weights? If TRUE, the sum of \code{w} is returned by group.
#' @param pd_evaluate_at An named list of evaluation points for one or more variables. Only relevant for type = "partial dependence".
#' @param pd_grid An evaluation \code{data.frame} with exactly two columns, e.g. generated by \code{expand.grid}. Only used for type = "partial dependence". Offers ultimate flexibility.
#' @param pd_indices A vector of row numbers to consider in calculating partial dependence profiles. Only used for type = "partial dependence".
#' @param pd_n_max Maximum number of ICE profiles to calculate (will be randomly picked from \code{data}). Only used for type = "partial dependence".
#' @param pd_seed Integer random seed used to select ICE profiles. Only used for type = "partial dependence".
#' @param ... Further arguments passed to \code{cut3} resp. \code{formatC} in forming the cut breaks of the \code{v} variables. Not relevant for partial dependence profiles.
#' @return An object of class \code{light_profile2d} with the following elements.
#' \itemize{
#'   \item \code{data} A tibble containing results. Can be used to build fully customized visualizations. Column names can be controlled by \code{options(flashlight.column_name)}.
#'   \item \code{by} Names of group by variables.
#'   \item \code{v} The two variable names evaluated.
#'   \item \code{type} Same as input \code{type}. For information only.
#' }
#' @export
#' @references
#' Friedman J. H. (2001). Greedy function approximation: A gradient boosting machine. The Annals of Statistics, 29:1189â€“1232.
#' @examples
#' fit <- lm(Sepal.Length ~ ., data = iris)
#' fl <- flashlight(model = fit, label = "iris", data = iris, y = "Sepal.Length")
#' light_profile2d(fl, v = c("Petal.Length", "Species"))
#' @seealso \code{\link{light_profile}}, \code{\link{plot.light_profile2d}}.
light_profile2d <- function(x, ...) {
  UseMethod("light_profile2d")
}

#' @describeIn light_profile2d Default method not implemented yet.
#' @export
light_profile2d.default <- function(x, ...) {
  stop("No default method available yet.")
}

#' @describeIn light_profile2d 2D profiles for flashlight.
#' @export
light_profile2d.flashlight <- function(x, v = NULL,
                                       data = NULL, by = x$by,
                                       type = c("partial dependence",
                                                "predicted", "response",
                                                "residual", "shap"),
                                       breaks = NULL, n_bins = 11,
                                       cut_type = "equal",
                                       use_linkinv = TRUE, counts = TRUE,
                                       counts_weighted = FALSE,
                                       pd_evaluate_at = NULL, pd_grid = NULL,
                                       pd_indices = NULL, pd_n_max = 1000,
                                       pd_seed = NULL, ...) {
  type <- match.arg(type)

  value_name <- getOption("flashlight.value_name")
  label_name <- getOption("flashlight.label_name")
  type_name <- getOption("flashlight.type_name")
  counts_name <- getOption("flashlight.counts_name")

  # Check if exactly two variables are specified
  if (type == "partial dependence" && !is.null(pd_grid)) {
    stopifnot(
      "pd_grid must be a data.frame" = is.data.frame(pd_grid),
      "pd_grid must have exactly two columns" = ncol(pd_grid) == 2L
    )
    v <- colnames(pd_grid)
  } else {
    stopifnot("Need exactly two 'v'." = length(v) == 2L)
  }

  # Turn binning arguments into a list of lists
  strategy <- fix_strategy(v, n_bins = n_bins, cut_type = cut_type,
                           breaks = breaks, pd_evaluate_at = pd_evaluate_at)

  # If SHAP, extract data
  if (type == "shap") {
    if (!is.shap(x$shap)) {
      stop("No shap values calculated. Run 'add_shap' for the flashlight first.")
    }
    stopifnot(v %in% colnames(x$shap$data))
    variable_name <- getOption("flashlight.variable_name")
    data <- x$shap$data[x$shap$data[[variable_name]] %in% v, ]
  } else if (is.null(data)) {
    data <- x$data
  }

  # Checks on data and column names
  stopifnot(
    "No data!" = is.data.frame(data) && nrow(data) >= 1L,
    "'by' not in 'data'!" = by %in% colnames(data),
    "'v' not in 'data'." = v %in% colnames(data),
    !anyDuplicated(c(by, v, value_name, label_name, type_name))
  )

  # Update flashlight
  if (type != "shap") {
    x <- flashlight(x, data = data, by = by,
                    linkinv = if (use_linkinv) x$linkinv else function(z) z)
  }

  # Calculate profiles
  if (type == "partial dependence") {
    # Construct pd_grid from strategy
    if (is.null(pd_grid)) {
      for (vv in v) {
        st <- strategy[[vv]]
        if (is.null(st$pd_evaluate_at)) {
          if (!is.null(st$breaks) && is.numeric(st$breaks)) {
            strategy[[vv]]$pd_evaluate_at <- midpoints(st$breaks)
          } else {
              strategy[[vv]]$pd_evaluate_at <-
                auto_cut(data[[vv]], n_bins = st$n_bins,
                         cut_type = st$cut_type, ...)$bin_means
          }
        }
      }
      pd_grid <- expand.grid(lapply(strategy, `[[`, "pd_evaluate_at"))
    }

    # Calculate 2D ICE profiles
    withr::with_options(list(flashlight.id_name = "id_xxx"),
      data <- light_ice(
        x = x, grid = pd_grid, indices = pd_indices,
        n_max = pd_n_max, seed = pd_seed)$data
    )
  } else {
    if (type %in% c("response", "residual") && is.null(x$y)) {
      stop("You need to specify 'y' in flashlight.")
    }

    # Add predictions/response to data
    data[[value_name]] <- switch(type,
      response = response(x),
      predicted = predict(x),
      residual = residuals(x),
      shap = data[["shap_"]]
    )

    # Replace v values by binned values
    for (vv in v) {
      st <- strategy[[vv]]
      data[[vv]] <- auto_cut(data[[vv]], n_bins = st$n_bins,
                             cut_type = st$cut_type,
                             breaks = st$breaks, ...)$data$level
    }
  }

  # Aggregate predicted values
  agg <- grouped_stats(data = data, x = value_name, w = x$w,
                       by = c(by, v), na.rm = TRUE, counts = counts,
                       counts_weighted = counts_weighted,
                       counts_name = counts_name)

  # Finalize results
  agg[[label_name]] <- x$label
  agg[[type_name]] <- type

  # Collect results
  out <- list(data = agg, by = by, v = v, type = type)
  add_classes(out, c("light_profile2d", "light"))
}

#' @describeIn light_profile2d 2D profiles for multiflashlight.
#' @export
light_profile2d.multiflashlight <- function(x, v = NULL, data = NULL,
                                            type = c("partial dependence",
                                                     "predicted", "response",
                                                     "residual", "shap"),
                                            breaks = NULL, n_bins = 11,
                                            cut_type = "equal",
                                            pd_evaluate_at = NULL,
                                            pd_grid = NULL, ...) {
  type <- match.arg(type)
  is_pd <- type == "partial dependence"

  if (is.null(pd_grid) || !is_pd) {
    stopifnot("Need exactly two 'v'." = length(v) == 2L)

    # Turn binning arguments into a list of lists
    strategy <- fix_strategy(v, n_bins = n_bins, cut_type = cut_type,
                             breaks = breaks, pd_evaluate_at = pd_evaluate_at)

    # Calculate common breaks for both variables independently
    for (vv in v) {
      st <- strategy[[vv]]
      if (is.null(st$breaks) && (is.null(st$pd_evaluate_at) || !is_pd)) {
        strategy[[vv]]$breaks <- common_breaks(
          x, v = vv, data = data, n_bins = st$n_bins,
          cut_type = st$cut_type
        )
      }
    }
    breaks <- lapply(strategy, `[[`, "breaks")
  }

  # Call light_profile2d for all flashlights
  all_profiles <- lapply(x, light_profile2d, v = v,
                         data = data, type = type,
                         breaks = breaks,
                         n_bins = n_bins, cut_type = cut_type,
                         pd_evaluate_at = pd_evaluate_at,
                         pd_grid = pd_grid, ...)
  light_combine(all_profiles, new_class = "light_profile2d_multi")
}
